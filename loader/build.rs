use build_config::{Config, LogLevel, MemoryMode};
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::{env, fs};

fn main() -> anyhow::Result<()> {
    let workspace_root = Path::new(env!("CARGO_RUSTC_CURRENT_DIR"));
    let out_dir = PathBuf::from(env::var_os("OUT_DIR").unwrap());

    let cfg_path = workspace_root.join(env!("K23_CONFIG"));
    let cfg = Config::from_file(&cfg_path).expect("failed to parse build config");

    let verifying_key = option_env!("K23_KERNEL_VERIFYING_KEY");
    let kernel_image = option_env!("K23_KERNEL_IMAGE");

    make_kconfig(&cfg, &out_dir, verifying_key, kernel_image)?;

    println!(
        "cargo:rustc-link-arg=-T{}",
        cfg.loader.linker_script.display()
    );
    println!("cargo:rerun-if-changed={}", cfg_path.display());

    if let Some(verifying_key) = verifying_key {
        println!("cargo:rerun-if-changed={verifying_key}");
    }

    if let Some(kernel_image) = kernel_image {
        println!("cargo:rerun-if-changed={kernel_image}");
    }

    Ok(())
}

fn make_kconfig(
    cfg: &Config,
    out_dir: &Path,
    verifying_key: Option<&str>,
    kernel_image: Option<&str>,
) -> anyhow::Result<()> {
    let stack_size_pages = cfg.loader.stack_size_pages;
    let kernel_stack_size_pages = cfg.kernel.stack_size_pages;
    let kernel_initial_stack_size_pages = cfg.kernel.initial_stack_size_pages;
    let log_level = match cfg.loader.log_level {
        LogLevel::Error => "::log::Level::Error",
        LogLevel::Warn => "::log::Level::Warn",
        LogLevel::Info => "::log::Level::Info",
        LogLevel::Debug => "::log::Level::Debug",
        LogLevel::Trace => "::log::Level::Trace",
    };

    let memory_mode = match cfg.memory_mode {
        MemoryMode::Riscv64Sv39 => "::vmm::Riscv64Sv39",
        MemoryMode::Riscv64Sv48 => "::vmm::Riscv64Sv48",
        MemoryMode::Riscv64Sv57 => "::vmm::Riscv64Sv57",
    };

    let verifying_key = if let Some(verifying_key_path) = verifying_key {
        format!(r#"include_bytes!("{verifying_key_path}")"#)
    } else {
        "&[0; ::ed25519_dalek::PUBLIC_KEY_LENGTH]".to_string()
    };

    let kernel_image = if let Some(kernel_image_path) = kernel_image {
        let len = fs::metadata(kernel_image_path)?.len();

        format!(r#"&[u8; {len}] = include_bytes!("{kernel_image_path}")"#)
    } else {
        "&[u8; 0] = &[]".to_string()
    };

    let mut file = File::create(out_dir.join("kconfig.rs"))?;
    writeln!(
        file,
        r#"// Generated by build.rs, do not touch!
    pub const KERNEL_STACK_SIZE_PAGES: usize = {kernel_stack_size_pages};
    pub const KERNEL_INITIAL_STACK_SIZE_PAGES: usize = {kernel_initial_stack_size_pages};
    pub const STACK_SIZE_PAGES: usize = {stack_size_pages};
    pub const LOG_LEVEL: ::log::Level = {log_level};
    #[allow(non_camel_case_types)]
    pub type MEMORY_MODE = {memory_mode};
    pub const PAGE_SIZE: usize = <MEMORY_MODE as ::vmm::Mode>::PAGE_SIZE;
    pub const VERIFYING_KEY: &[u8; ::ed25519_dalek::PUBLIC_KEY_LENGTH] = {verifying_key};
    pub const KERNEL_IMAGE: {kernel_image};
    "#
    )?;

    Ok(())
}
